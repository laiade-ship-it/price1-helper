async function performOCR(input) {
        if (!input.files || !input.files[0]) return;
        const status = document.getElementById('ocr-status');
        status.innerText = "⌛ 辨識中...";
        
        try {
            const r = await Tesseract.recognize(input.files[0], 'chi_tra+jpn+eng');
            const fullText = r.data.text;
            const lines = fullText.split('\n').map(l => l.trim()).filter(l => l.length > 1);

            // 1. 價格邏輯：語意化過濾
            const priceRegex = /([$¥]|NT\$)?\s?(\d{1,3}(,\d{3})*(\.\d+)?|\d+(\.\d+)?)/gi;
            const matches = fullText.match(priceRegex) || [];
            
            const priceCandidates = matches.map(m => {
                const clean = m.replace(/[^\d.]/g, '');
                return {
                    raw: m,
                    val: parseFloat(clean),
                    hasSymbol: /[$¥]|NT\$/i.test(m),
                    digitLength: clean.split('.')[0].length
                };
            }).filter(c => 
                c.val > 0 && 
                c.digitLength <= 5 && // 排除條碼 (通常 > 5 位數)
                !/\d{4}[/-]\d{2}[/-]\d{2}/.test(c.raw) // 排除日期格式
            );

            // 決策：有符號優先；若無符號，取 10~5000 元間的最大值 (避開型號/年份)
            let finalPriceObj = priceCandidates.find(c => c.hasSymbol);
            if (!finalPriceObj) {
                const reasonablePrices = priceCandidates.filter(c => c.val > 10 && c.val < 5000);
                finalPriceObj = reasonablePrices.sort((a,b) => b.val - a.val)[0];
            }
            if (finalPriceObj) document.getElementById('price').value = finalPriceObj.val;

            // 2. 名稱邏輯：排除功能性說明
            const blacklist = ['產地', '地址', '電話', '日期', '保存', '有限', '公司', 'Tel', '份', '及', 'Ingredients', '配方'];
            
            const filteredLines = lines.map(line => {
                const textOnly = line.replace(/[\d\s,.$¥NT:：xX*＊\-/]/g, '');
                const ratio = line.length > 0 ? textOnly.length / line.length : 0;
                const hasBlacklist = blacklist.some(word => line.includes(word));
                return { line, ratio, hasBlacklist, len: line.length };
            }).filter(item => 
                !item.hasBlacklist && 
                item.ratio > 0.6 && // 文字比例需高於 60%
                item.len >= 2 && item.len <= 20 // 排除雜訊或過長段落
            );

            // 取篩選後比例最高的第一行
            if (filteredLines.length > 0) {
                const bestName = filteredLines.sort((a,b) => b.ratio - a.ratio)[0].line;
                // 去除可能殘留的行末數字
                document.getElementById('itemName').value = bestName.replace(/[$¥NT\d,.]+$/g, '').trim();
            }
            
            status.innerText = "✅ 辨識完成";
            calculate(); updateHistory();
        } catch (e) {
            status.innerText = "❌ 辨識失敗";
        }
    }
